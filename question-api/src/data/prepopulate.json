[
  {
    "title": "Two Sum",
    "difficulty": "Easy",
    "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
    "examples": [
      {
        "in": "[2,7,11,15], 9",
        "out": "[0, 1]",
        "explanation": "Because nums[0] + nums[1] == 9, we return [0, 1]."
      }
    ],
    "constraints": [
      "2 <= nums.length <= 104",
      "-109 <= nums[i] <= 109",
      "-109 <= target <= 109",
      "Only one valid answer exists."
    ]
  },
  {
    "title": "Add Two Numbers",
    "difficulty": "Medium",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
    "examples": [
      {
        "in": "(2 -> 4 -> 3) + (5 -> 6 -> 4)",
        "out": "7 -> 0 -> 8",
        "explanation": "342 + 465 = 807."
      }
    ],
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= Node.val <= 9",
      "It is guaranteed that the list represents a number that does not have leading zeros."
    ]
  },
  {
    "title": "Array Pair Sum",
    "difficulty": "Easy",
    "description": "Given an array of integers, return indices of the two numbers such that they add up to a specific target.",
    "examples": [
      {
        "input": "[2, 7, 11, 15], target = 9",
        "output": "[0, 1]"
      },
      {
        "input": "[3, 2, 4], target = 6",
        "output": "[1, 2]"
      }
    ],
    "constraints": [
      "2 <= nums.length <= 10^3",
      "-10^9 <= nums[i] <= 10^9",
      "There is exactly one solution."
    ]
  },
  {
    "title": "Reverse Integer",
    "difficulty": "Easy",
    "description": "Given a 32-bit signed integer, reverse digits of an integer.",
    "examples": [
      {
        "input": "123",
        "output": "321"
      },
      {
        "input": "-123",
        "output": "-321"
      }
    ],
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ]
  },
  {
    "title": "Palindrome Number",
    "difficulty": "Easy",
    "description": "Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.",
    "examples": [
      {
        "input": "121",
        "output": "true"
      },
      {
        "input": "-121",
        "output": "false"
      }
    ],
    "constraints": [
      "-2^31 <= x <= 2^31 - 1"
    ]
  },
  {
    "title": "Roman to Integer",
    "difficulty": "Easy",
    "description": "Given a roman numeral, convert it to an integer.",
    "examples": [
      {
        "input": "\"III\"",
        "output": "3"
      },
      {
        "input": "\"IV\"",
        "output": "4"
      }
    ],
    "constraints": [
      "1 <= s.length <= 15",
      "s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M')"
    ]
  },
  {
    "title": "Longest Common Prefix",
    "difficulty": "Easy",
    "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".",
    "examples": [
      {
        "input": "[\"flower\",\"flow\",\"flight\"]",
        "output": "\"fl\""
      },
      {
        "input": "[\"dog\",\"racecar\",\"car\"]",
        "output": "\"\""
      }
    ],
    "constraints": [
      "1 <= strs.length <= 200",
      "0 <= strs[i].length <= 200",
      "strs[i] consists of only lower-case English letters."
    ]
  },
  {
    "title": "Merge Two Sorted Lists",
    "difficulty": "Easy",
    "description": "Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.",
    "examples": [
      {
        "input": "1->2->4, 1->3->4",
        "output": "1->1->2->3->4->4"
      },
      {
        "input": "null, 0->3->3",
        "output": "0->3->3"
      }
    ],
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50].",
      "-100 <= Node.val <= 100"
    ]
  },
  {
    "title": "Remove Duplicates from Sorted Array",
    "difficulty": "Easy",
    "description": "Given a sorted array nums, remove the duplicates in-place such that each element appears only once and returns the new length.",
    "examples": [
      {
        "input": "[1,1,2]",
        "output": "2, nums = [1,2]"
      },
      {
        "input": "[0,0,1,1,1,2,2,3,3,4]",
        "output": "5, nums = [0,1,2,3,4]"
      }
    ],
    "constraints": [
      "0 <= nums.length <= 3 * 10^4",
      "-10^4 <= nums[i] <= 10^4",
      "nums is sorted in ascending order."
    ]
  },
  {
    "title": "Remove Element",
    "difficulty": "Easy",
    "description": "Given an array nums and a value val, remove all instances of that value in-place and return the new length.",
    "examples": [
      {
        "input": "[3,2,2,3], val = 3",
        "output": "2, nums = [2,2]"
      },
      {
        "input": "[0,1,2,2,3,0,4,2], val = 2",
        "output": "5, nums = [0,1,4,0,3]"
      }
    ],
    "constraints": [
      "0 <= nums.length <= 100",
      "0 <= nums[i] <= 50",
      "0 <= val <= 100"
    ]
  },
  {
    "title": "Implement strStr()",
    "difficulty": "Easy",
    "description": "Implement strStr(). Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.",
    "examples": [
      {
        "input": "haystack = \"hello\", needle = \"ll\"",
        "output": "2"
      },
      {
        "input": "haystack = \"aaaaa\", needle = \"bba\"",
        "output": "-1"
      }
    ],
    "constraints": [
      "0 <= haystack.length, needle.length <= 5 * 10^4",
      "haystack and needle consist of only lower-case English characters."
    ]
  },
  {
    "title": "Balanced Substring Finder",
    "difficulty": "Medium",
    "description": "Given a string s consisting of only '0's and '1's, write a function to find the length of the longest substring where the number of '0's and '1's are equal. If no such substring exists, return 0.",
    "examples": [
      {
        "input": "s = \"110100110\"",
        "output": "6"
      },
      {
        "input": "s = \"1001\"",
        "output": "4"
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^4",
      "s[i] is either '0' or '1'"
    ]
  },
  {
    "title": "Array Peak Element",
    "difficulty": "Medium",
    "description": "Given an array of integers, find a peak element in it. An element is peak if it is NOT smaller than its neighbors. For corner elements, we need to consider only one neighbor.",
    "examples": [
      {
        "input": "[1, 3, 20, 4, 1, 0]",
        "output": "20"
      },
      {
        "input": "[10, 20, 15, 2, 23, 90, 67]",
        "output": "20 or 90"
      }
    ],
    "constraints": [
      "1 <= arr.length <= 10^4",
      "-10^4 <= arr[i] <= 10^4"
    ]
  },
  {
    "title": "Matrix Diagonal Sum",
    "difficulty": "Medium",
    "description": "Given a square matrix mat, return the sum of the matrix diagonals. Only include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.",
    "examples": [
      {
        "input": "[[1,2,3],[4,5,6],[7,8,9]]",
        "output": "25"
      },
      {
        "input": "[[1,1,1,1],[1,1,1,1],[1,1,1,1],[1,1,1,1]]",
        "output": "8"
      }
    ],
    "constraints": [
      "n == mat.length == mat[i].length",
      "1 <= n <= 100",
      "1 <= mat[i][j] <= 100"
    ]
  },
  {
    "title": "Valid Parentheses String",
    "difficulty": "Medium",
    "description": "Given a string s containing only three types of characters: '(', ')' and '*', write a function to check whether this string is valid. The '*' character can be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string.",
    "examples": [
      {
        "input": "s = \"(*)\"",
        "output": "true"
      },
      {
        "input": "s = \"(*))\"",
        "output": "true"
      }
    ],
    "constraints": [
      "1 <= s.length <= 100",
      "s[i] is '(', ')' or '*'"
    ]
  },
  {
    "title": "Maximum Product Subarray",
    "difficulty": "Medium",
    "description": "Given an integer array nums, find a contiguous non-empty subarray within the array that has the largest product, and return the product.",
    "examples": [
      {
        "input": "[2,3,-2,4]",
        "output": "6"
      },
      {
        "input": "[-2,0,-1]",
        "output": "0"
      }
    ],
    "constraints": [
      "1 <= nums.length <= 2 * 10^4",
      "-10 <= nums[i] <= 10",
      "The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer."
    ]
  },
  {
    "title": "Longest Increasing Path in a Matrix",
    "difficulty": "Hard",
    "description": "Given an m x n integers matrix, return the length of the longest increasing path in the matrix. From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary.",
    "examples": [
      {
        "input": "[[9,9,4],[6,6,8],[2,1,1]]",
        "output": "4"
      },
      {
        "input": "[[3,4,5],[3,2,6],[2,2,1]]",
        "output": "4"
      }
    ],
    "constraints": [
      "m == matrix.length",
      "n == matrix[i].length",
      "1 <= m, n <= 200",
      "0 <= matrix[i][j] <= 231 - 1"
    ]
  },
  {
    "title": "Minimum Window Substring",
    "difficulty": "Hard",
    "description": "Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string ''.",
    "examples": [
      {
        "input": "s = 'ADOBECODEBANC', t = 'ABC'",
        "output": "'BANC'"
      },
      {
        "input": "s = 'a', t = 'a'",
        "output": "'a'"
      }
    ],
    "constraints": [
      "1 <= m, n <= 105",
      "s and t consist of English letters."
    ]
  },
  {
    "title": "Binary Tree Maximum Path Sum",
    "difficulty": "Hard",
    "description": "Given a non-empty binary tree, find the maximum path sum. The path may start and end at any node in the tree.",
    "examples": [
      {
        "input": "[1,2,3]",
        "output": "6"
      },
      {
        "input": "[-10,9,20,null,null,15,7]",
        "output": "42"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [0, 3 * 104].",
      "-1000 <= Node.val <= 1000"
    ]
  },
  {
    "title": "Serialize and Deserialize Binary Tree",
    "difficulty": "Hard",
    "description": "Design an algorithm to serialize and deserialize a binary tree. Serialization is the process of converting a binary tree into a string so that it can be stored on disk. Deserialization is the opposite process, turning a string back into a binary tree.",
    "examples": [
      {
        "input": "[1,2,3,null,null,4,5]",
        "output": "[1,2,3,null,null,4,5]"
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [0, 104].",
      "-1000 <= Node.val <= 1000"
    ]
  }
]